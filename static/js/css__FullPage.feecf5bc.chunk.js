(window.webpackJsonpfrontend=window.webpackJsonpfrontend||[]).push([[9],{133:function(e,a,t){"use strict";var n=t(0),i=t.n(n),o=t(129),s=t(38),r=t(124),l=t(25),u=t(121),m=t(122),c=t(123),d=t(39),p=t(65),b=t(47),h=Object(p.a)((function(e){return{Question:{fontWeight:500},Answer:{marginTop:e.spacing(1.5),padding:0,fontSize:14,backgroundColor:b.a[50],border:"1px solid ".concat(b.a[400]),borderRadius:6,"& p":{padding:e.spacing(0,2.5)},"& ol,ul":{margin:e.spacing(1.5,0)},"& img":{maxWidth:"100%"}},References:{margin:e.spacing(3,0,0),"& ol":{marginTop:e.spacing(1)},"& li":{fontSize:14,fontWeight:500,marginBottom:e.spacing(1)}}}})),v=Object(n.memo)((function(e){var a=e.index,t=e.question,n=e.answer,r=e.references,p=h(),b=Object(d.a)(!1),v=Object(l.a)(b,2),f=v[0],g=v[1];return i.a.createElement(i.a.Fragment,null,i.a.createElement(u.a,{button:!0,onClick:g},i.a.createElement(m.a,{classes:{primary:p.Question}},a,". ",t)),i.a.createElement(c.a,{in:f,timeout:"auto"},i.a.createElement(o.a,{className:p.Answer},n),!!r&&r.length&&i.a.createElement(o.a,{className:p.References},i.a.createElement(s.a,{variant:"h4"},"References"),i.a.createElement("ol",null,r.map((function(e){var a=e.name,t=e.url;return i.a.createElement("li",{key:t},i.a.createElement("a",{href:t,target:"_blank",rel:"noopener noreferrer"},a))}))))))}));v.displayName="QuestionItem";var f=v,g=Object(p.a)((function(e){return{Container:{marginTop:e.spacing(4)},Content:{marginTop:e.spacing(2.5)},Questions:{marginTop:e.spacing(4),"& code":{fontFamily:"'Courier New', Courier, monospace",fontSize:14,fontWeight:600,color:"rgb(219, 104, 27)"}}}})),y=Object(n.memo)((function(e){var a=e.title,t=e.questions,n=e.children,l=g();return i.a.createElement(o.a,{className:l.Container},i.a.createElement(s.a,{variant:"h2"},a),i.a.createElement(o.a,{className:l.Content},n),i.a.createElement(o.a,{className:l.Questions},i.a.createElement(s.a,{variant:"h3"},"Questions"),i.a.createElement(o.a,null,i.a.createElement(r.a,null,t.map((function(e,a){return i.a.createElement(f,Object.assign({key:a,index:a+1},e))}))))))}));y.displayName="QuestionPage";a.a=y},403:function(e,a,t){e.exports={Container:"styles_Container__2O4_o",Ads:"styles_Ads__36Di2",AdsImg:"styles_AdsImg__3Yc1N",Window:"styles_Window__1RP6s"}},480:function(e,a,t){"use strict";t.r(a);var n=t(0),i=t.n(n),o=t(133),s=[{question:"This is undone",answer:null}],r=t(403),l=t.n(r);t.d(a,"FullPage1Impl",(function(){return u}));var u=function(){return i.a.createElement(o.a,{title:"",questions:s},"Unimplemented",i.a.createElement("div",{className:l.a.Container},i.a.createElement("p",null,"debounceTime delays values emitted by the source Observable, but drops previous pending delayed emissions if a new value arrives on the source Observable. This operator keeps track of the most recent value from the source Observable, and emits that only when dueTime enough time has passed without any other value appearing on the source Observable. If a new value appears before dueTime silence occurs, the previous value will be dropped and will not be emitted on the output Observable."),i.a.createElement("p",null,"This is a rate-limiting operator, because it is impossible for more than one value to be emitted in any time window of duration dueTime, but it is also a delay-like operator since output emissions do not occur at the same time as they did on the source Observable. Optionally takes a SchedulerLike for managing timers."),i.a.createElement("p",null,"debounceTime delays values emitted by the source Observable, but drops previous pending delayed emissions if a new value arrives on the source Observable. This operator keeps track of the most recent value from the source Observable, and emits that only when dueTime enough time has passed without any other value appearing on the source Observable. If a new value appears before dueTime silence occurs, the previous value will be dropped and will not be emitted on the output Observable."),i.a.createElement("p",null,"This is a rate-limiting operator, because it is impossible for more than one value to be emitted in any time window of duration dueTime, but it is also a delay-like operator since output emissions do not occur at the same time as they did on the source Observable. Optionally takes a SchedulerLike for managing timers."),i.a.createElement("p",null,"debounceTime delays values emitted by the source Observable, but drops previous pending delayed emissions if a new value arrives on the source Observable. This operator keeps track of the most recent value from the source Observable, and emits that only when dueTime enough time has passed without any other value appearing on the source Observable. If a new value appears before dueTime silence occurs, the previous value will be dropped and will not be emitted on the output Observable."),i.a.createElement("div",{className:l.a.Ads},i.a.createElement("div",{className:l.a.AdsImg})),i.a.createElement("p",null,"This is a rate-limiting operator, because it is impossible for more than one value to be emitted in any time window of duration dueTime, but it is also a delay-like operator since output emissions do not occur at the same time as they did on the source Observable. Optionally takes a SchedulerLike for managing timers."),i.a.createElement("p",null,"debounceTime delays values emitted by the source Observable, but drops previous pending delayed emissions if a new value arrives on the source Observable. This operator keeps track of the most recent value from the source Observable, and emits that only when dueTime enough time has passed without any other value appearing on the source Observable. If a new value appears before dueTime silence occurs, the previous value will be dropped and will not be emitted on the output Observable."),i.a.createElement("p",null,"This is a rate-limiting operator, because it is impossible for more than one value to be emitted in any time window of duration dueTime, but it is also a delay-like operator since output emissions do not occur at the same time as they did on the source Observable. Optionally takes a SchedulerLike for managing timers."),i.a.createElement("p",null,"debounceTime delays values emitted by the source Observable, but drops previous pending delayed emissions if a new value arrives on the source Observable. This operator keeps track of the most recent value from the source Observable, and emits that only when dueTime enough time has passed without any other value appearing on the source Observable. If a new value appears before dueTime silence occurs, the previous value will be dropped and will not be emitted on the output Observable."),i.a.createElement("p",null,"This is a rate-limiting operator, because it is impossible for more than one value to be emitted in any time window of duration dueTime, but it is also a delay-like operator since output emissions do not occur at the same time as they did on the source Observable. Optionally takes a SchedulerLike for managing timers."),i.a.createElement("p",null,"debounceTime delays values emitted by the source Observable, but drops previous pending delayed emissions if a new value arrives on the source Observable. This operator keeps track of the most recent value from the source Observable, and emits that only when dueTime enough time has passed without any other value appearing on the source Observable. If a new value appears before dueTime silence occurs, the previous value will be dropped and will not be emitted on the output Observable."),i.a.createElement("p",null,"This is a rate-limiting operator, because it is impossible for more than one value to be emitted in any time window of duration dueTime, but it is also a delay-like operator since output emissions do not occur at the same time as they did on the source Observable. Optionally takes a SchedulerLike for managing timers.")))},m=Object(n.memo)(u);m.displayName="FullPage1";a.default=m}}]);
//# sourceMappingURL=css__FullPage.feecf5bc.chunk.js.map